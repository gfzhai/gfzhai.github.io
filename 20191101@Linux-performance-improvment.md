# 《Linux性能优化实践》学习笔记

> 在上下班路上粗听了一遍倪朋飞老师的这个系列课程，让我弄清了很多原来似是而非的基本概念。所以，打算集中一段时间好好学习一下这个系列的课程，实际操作一下课程中的例子，并将心得体会记录在本文中。


**课程连接**: [Linux性能优化实践](https://time.geekbang.org/column/intro/140)

## 开篇词 | 别再让Linux性能问题成为你的绊脚石

* 把观察到的性能问题跟系统原理关联起来，特别是把系统从应用程序、库函数、系统调用、再到内核和硬件等不同的层级贯穿起来。
> 在学习这个系列课程之前，我处理现场的性能问题时大都靠临时的搜索去完成，通过搜索引擎搜索到的东西零碎不成体系，有时后可以能够发挥作用，常常需要不断的去尝试不同的解决方案。解决问题后，有时也不能了解其中的原理。我想这就是没有贯通，没有从上到下打通问题从现象到本质，再到原理的路径，犹如习练武功，外功招式多，经脉未打通，内力有限。希望通过这个系列的课程，打通性能的任督二脉，内力更上一个台阶。

* 性能优化是个系统工程，总是牵一发而动全身。
> 众里寻她千百度。

* 性能优化是软件系统中最有挑战的工作之一，但是换个角度看，它也是最考验体现你综合能力的工作之一。

* 最好的学习方式一定是带着问题学习。
> 就是有目的的学习。

* 想要得到你就要学会付出，要付出还要坚持；如果你真的觉得很难，那你就放弃，如果你放弃了就不要抱怨。人生就是这样，世界是平衡的，每个人都是通过自己的努力，去决定自己生活的样子。
> 选择、努力。


## 01 | 如何学习Linux性能优化？

* 建立起整体性能的全局观
> 理解原理，进行实践，也就是理论联系实际，知行合一。


* 性能指标是什么？
> 我们谈及性能，自然要明白性能的基本概念。性能指标就是观察性能的角度和衡量的标准。
> 文中从两个视角去观察性能: 一是应用的视角，即应用负载的指标，表示应用用了多少？；另一个是系统的视角，即系统资源的指标，表示还能用多少？
> 性能问题的本质是应用负载的增加导致系统资源达到瓶颈，这两者本来就是一对矛盾体，此消彼长。

* 解决性能问题的步骤: 
> 六个步骤：
```
    1.选择指标评估应用程序和系统的性能
    2.为应用程序和系统设置性能目标
    3.进行性能基准测试
    4.性能分析定位瓶颈
    5.优化系统和应用程序
    6.性能监控和告警 
```

* 学习的重点是什么？
> “道”：理解最基本的几个系统知识原理；“器”:掌握必要的性能工具；“运用”：通过实际的场景演练，贯穿不同的组件

* 布伦丹·格雷格
> 大师，膜拜 网站[Linux Performance](http://www.brendangregg.com/linuxperf.html)

* 千万不要把性能工具当成学习的全部
> 工具是器，更重要的是掌握道

* 如何高效学习
> 技巧一：不要试图抓住所有的实现细节，抓重点，20-80原则；技巧二：边学边实践，知行合一；技巧三：勤思考、多反思、善总结，多问为什么

## 02 | 基础篇：到底应该怎么理解“平均负载”？

* 平均负载
> 可以通过man uptime来显示系统平均负载的定义(不能使用中文的language)
> 平均负载是在单位时间内，系统处于可运行状态和不可终中断状态的平均进程数

* 进程的状态
> RDSTZ
```
    R
        可运行状态 Running or runnable
        表示正在运行或在运行队列上等待运行
    D
        不可中断的睡眠状态 Uninterruptible sleep
        通常是一个系统关键的系统调用
    S
        可中断的睡眠状态 Interruptible sleep
        表示正在等待事件
    T
        停止状态 Stopped
        由于被挂起或被追踪
    Z
        僵尸状态 Defunct (zombie)
        进程已经退出，但其父进程并没有回收进程
```

* 平均负载为多少时合理
> 首先需要知道系统有几个CPU
```
    grep 'model name' /proc/cpuinfo | wc -l
```
> 平均负载的三个值提供了系统负载趋势的数据。当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题

* 平均负载与 CPU 使用率
> 平均负载不仅包括正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。CPU使用率是单位时间内 CPU 繁忙情况的统计。
```
    关系
        CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
        I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
        大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。
```

* 平均负载提供一个快速查看系统整体性能的手段，反映了整体的负载情况。单只看平均负载本身，并不能直接发现哪里出现了瓶颈
> 几点认识：
```
    1. 平均负载高可能是CPU密集型进程导致的
    2. 平均负载高并不一定代表CPU使用率高，还有可能是IO更繁忙了
    3. 当负载高的时候，可以使用mpstat, pidstat等工具辅助分析负载的来源
```

## 03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上） 

* 进程在竞争 CPU 的时候并没有真正运行，为什么还会导致系统的负载升高呢？
> CPU 上下文切换就是罪魁祸首

* CPU上下文
> CPU寄存器 和 程序计数器PC

* CPU上下文切换
> 进程上下文件切换、线程上下文切换和中断上下文切换

* 系统调用
> 特权模式切换，也是CPU的上下文切换（1. 用户态切换到内核态; 2.内核态切换到用户态）

* 进程上下文切换
> 用户态（虚拟内存、栈、全局变量）；内核态（CPU寄存器）

* 进程调度策略
> 进程就绪队列（活跃进程，优先级最高和等待CPU时间最长）

* 进程调度的场景
```
    时间片
    等待系统资源
    sleep
    高优先级抢占
    中断
```

* 上下文切换的时间
> 几十纳秒到几微妙

* TLB
> 虚拟内存到物理内存的映射


* 线程上下文切换
> 线程是调度的基本单位，而进程是资源占用的基本单位。也就是一个进程中的线程是共享资源的。同进程内的线程切换比多进程间的线程切换消耗更少的资源。

* 中断上下文切换
> 不涉及到进程的用户态；中断比进程的优先级更高

## 04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）

* 怎么查看系统的上下文切换情况
> vmstat - 查看系统整体情况； 
> pidstat - 查看具体的进程情况

* 自愿上下文切换
> 进程无法获取所需资源导致的上下文切换，如IO、内存资源不足时

* 非自愿上下文切换
> 由于时间片已到等原因，被系统强制调度，进而发生的上下文切换，如大量进程争抢CPU

**案例分析经验**
* 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
```
    vmstat
    pidstat -wt
```

* 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
```
    vmstat
    pidstat -wt
```

* 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。
```
    cat /proc/interrupts
```

## 05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？

* CPU使用率
> 除了空闲时间外的其它时间占CPU总时间的百分比

* Linux的内核节拍率
> 可以查看Linux的节拍率的配置
```
    $ grep 'CONFIG_HZ=' /boot/config-$(uname -r)
    CONFIG_HZ=250
```

* 用户节拍率USER_HZ
> 始终为100

* Linux系统的CPU和任务的统计信息
> 通过命令查看/proc/stat中相关的信息
```
    $ cat /proc/stat | grep ^cpu
    cpu  280580 7407 286084 172900810 83602 0 583 0 0 0
    cpu0 144745 4181 176701 86423902 52076 0 301 0 0 0
    cpu1 135834 3226 109383 86476907 31525 0 282 0 0 0
```

* CPU使用率相关的重要指标
> 通过man proc命令查看
```
    user(us)            用户态CPU时间，不包括nice时间，包括guest时间
    nice(ni)            低优先级用户态CPU时间，优先级1~19
    system(sys)         内核态CPU时间
    idle(id)            空闲时间，不包括等待io的时间
    iowait(wa)          等待磁盘IO的CPU时间
    irq(hi)             处理硬中断的CPU时间
    softirq(si)         处理软中断的CPU时间
    steal(st)           系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间
    guest(guest)        通过虚拟机运行其他操作系统的时间，也就是运行虚拟机的CPU时间
    guest_nice(gnice)   以低优先级运行虚拟机的时间
```

* 每个进程的运行情况
> 通过命令查看/proc/[PID]/stat中的相关信息

* 性能分析工具给出的都是间隔一段时间的平均 CPU 使用率，所以要注意间隔时间的设置

